Dragonfly is based on discrete logarithm cryptography, which means one can use operations either in a finite fieldor an elliptic curve. In it's definition in \cite{Ha15}, no assumptions are made about the underlying group, only thatcalculating discrete logarithms is difficult enough to provide a baseline level of security.As an example execution of the protocol, we will look at the finite field case. Let $p$ be a large prime. We will denote $Q$ as a cyclic subgroupof $\mathbb{Z}_p^*$ with prime order $q$ -- hence $q | p-1$. In addition to $p$ and $q$, a hash function $H$ is also agreed upon.The protocol then executes as follows:\begin{enumerate}    \item Alice and Bob have a shared password which they both map to an element $\pi \in Q$. The protocol specification maps the password        arbitrarily (but deterministically) to the element $\pi$, and includes some example algorithms to perform the actual mapping. These        examples are omitted here.    \item Alice chooses two random values $r_A, m_A \in_R \mathbb{Z}_q^*$. She computes $s_A = r_A + m_A \mod q$ and the element        $E_A = \pi^{-m_A} \mod p$. If $s_A < 2$ (to avoid the small subgroup attack), start this step over. She sends $s_A$ and $E_A$ to Bob.        \label{enum:dragonfly2}    \item Bob chooses two random values $r_B, m_B \in_R \mathbb{Z}_q^*$. He computes $s_B = r_B + m_B \mod q$ and the element        $E_B = \pi^{-m_B} \mod p$. If $s_B < 2$, start this step over. He sends $s_A$ and $E_A$ to Alice.        \label{enum:dragonfly3}    \item Each member verifies that one of $E_A \neq E_B$ or $s_A \neq s_B$ is true to avoid a reflection attack.    \item Alice computes the shared secret $ss = (\pi^{s_B} E_B)^{r_A} = \pi^{r_A r_B} \mod p$. Alice sends $A = H(ss || E_A || s_A || E_B || s_B)$ to Bob.    \item Bob computes the shared secret $ss = (\pi^{s_A} E_A)^{r_B} = \pi^{r_A r_B} \mod p$. Bob sends $B = H(ss || E_B || s_B || E_A || s_A)$ to Alice.    \item Alice and Bob both confirm the received hash values are correct and compute the shared key $K = H(ss || E_A \times E_B || (s_A + s_B) \mod q)$.\end{enumerate}This protocol is illustrated in Figure \ref{fig:dragonfly}.\begin{figure}[h]    \begin{tikzpicture}        \matrix (m)[matrix of nodes, column sep=1cm, column 2/.style={minimum width=1.5cm}, nodes in empty cells]{            Alice                                           &                   & Bob                                           \\            repeat: randomly choose $r_A, m_A \in \mathbb{Z}_q^*$   &   & repeat: randomly choose $r_B, m_B \in \mathbb{Z}_q^*$ \\            $s_A = r_A + m_A \mod q$ until $s_A \geq 2$     &                   & $s_B = r_B + m_B \mod q$ until $s_B \geq 2$   \\            $E_A = \pi^{-m_A} \mod p$                       & $s_A, E_A$        & $E_B = \pi^{-m_B} \mod p$                     \\                                                            & $s_B, E_B$        &                                               \\                                                            &                   &                                               \\            Verify $E_A \neq E_B$ or $s_A \neq s_B$         &                   & Verify $E_A \neq E_B$ or $s_A \neq s_B$       \\            $ss = (\pi^{s_B} E_B)^{r_A} = \pi^{r_A r_B} \mod p$  &       & $ss = (\pi^{s_A} E_A)^{r_B} = \pi^{r_A r_B} \mod p$  \\            $A = H(ss || E_A || s_A || E_B || s_B)$         & $A$               & $B = H(ss || E_B || s_B || E_A || s_A)$       \\                                                            & $B$               &                                               \\            Verify $B$                                      &                   & Verify $A$                                    \\            $K = H(ss || E_A \times E_B || (s_A + s_B) \mod q)$  &       & $K = H(ss || E_A \times E_B || (s_A + s_B) \mod q)$  \\        };        % draw the nodes - these are 1-based indicies on the matrix called `m`, ie to draw in (x,y), reference it as `m-x-y`        \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-1.south east)--(m-1-1.south west);        % underline "Alice"        \draw[shorten <=-1.5cm,shorten >=-1.5cm] (m-1-3.south east)--(m-1-3.south west);        % underline "Bob"        \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-4-2.south west)--(m-4-2.south east);     % arrow below sending s_A, E_A        \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-5-2.south east)--(m-5-2.south west);     % arrow below sending s_B, E_B        \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-9-2.south west)--(m-9-2.south east);     % arrow below sending A        \draw[shorten <=-1cm,shorten >=-1cm,-latex] (m-10-2.south east)--(m-10-2.south west);   % arrow below sending B    \end{tikzpicture}    \caption{The Dragonfly protocol.}    \label{fig:dragonfly}\end{figure}Steps \ref{enum:dragonfly2} and \ref{enum:dragonfly3} were modified in the most recent update to the Dragonfly protocol. A small subgroup attackwas discovered in \cite{Ha2014}. The protocol works around this now by checking $s_A$ and $s_B$ and repeating the step until the values generated are safe.Dragonfly claims to be resistant to offline dictionary attacks, but does not provide any security proofs. However, due to the small exponentiation size(limited by $q$), it is very quick. As our results show in Section \ref{sec:Implementation}, Dragonfly+ is the fastest protocol tested.