We now turn out attention to the group setting, where $n$ agents all share knowledge of a common password $\pi$ and wish to establish a shared secure group key $K$ (to be explicit, knowledge of the shared password is the only thing that makes an agent an authentic group member).  Although there has been some previous work on this topic, much of it -- see, for instance, Dutta and Barua~\cite{DuBa06} -- required $O(n)$ rounds of communication to establish the shared group key, which is an issue as the protocol can easily be disrupted by one slow participant (for instance, setting up a group key with 10 participants would require around 10 rounds of communication, and meaning the group would have to wait for the slowest responder 10 times)\footnote{To be fair, the construction of Hao et. al. has security properties which are proven in an informal attack model while the scheme of Dutta and Barua is proven secure in the widely accepted BPR model of Bellare et. al.~\cite{BePoRo00} under the CDH assumption in the random oracle model.  Also, the greatly decreased number of rounds comes with more computational work for each group member.}.  In 2006, Abdalla et. al.~\cite{AbBrChPo06} gave a GPAKE using only 4 rounds of communication (independent of $n$), a significant improvement.  Furthermore, in 2015 Hao et. al.~\cite{HaYiChSh15} outlined a general method -- which they called the `fairy-ring dance', due to a similarity between its structure of establishing pairwise keys and a traditional Scottish country dance -- of taking a PAKE using finite fields and transforming it into a GPAKE which has at most one additional round of communication (so the number of rounds of communication will again be independent of the number of members in the group)\footnote{The resulting GPAKE will always have at least two rounds of communication.}.  The paper of Hao et. al. continued on to give two explicit GPAKEs using this construction based on the SPEKE and J-PAKE protocols detailed in the previous section.  We describe their algorithms, together with two new GPAKEs we have created using this general construction, based on the Dragonfly and PPK protocols described above.
\\

Before describing these GPAKEs, we give a general overview of how the generic construction works (using a bit more detail than in the original paper of Hao et. al.~\cite{HaYiChSh15}, which puts a larger focus on the explicit methods SPEKE+ and J-PAKE+).  Essentially, the construction proceeds as follows:
\\

\begin{itemize} \itemsep=1.2em
\item Each pair of members $P_i,P_j$ in the group will compute a two-party pairwise key $K_{ij}$ using some two-party PAKE protocol.  All information is broadcast simultaneously by each group member
\item At the same time, each participant $P_i$ chooses another random element $y_i$ of the finite field in which the PAKE operations are performed, and broadcasts $g^{y_i}$ together with a Zero Knowledge Proof (for instance, the Schnorr ZKP detailed in the previous section) ZKP$\{y_i\}$ that $P_i$ knows the exponent $y_i$.  Each participant $P_i$ then computes $g^{z_i} = g^{y_{i+1}}/g^{y_{i-1}}$, where indices are taken modulo $n$.
\item  Each $P_i$ broadcasts $(g^{z_i})^{y_i}$ and a Zero Knowledge Proof ZKP$\{\tilde{y_i}\}$ that the discrete logarithm of $(g^{z_i})^{y_i}$ with respect to the base $g^{z_i}$ is equal to the discrete logarithm of $g^{y_i}$ with respect to the base $g$. For this we use the well known Chaum-Pedersen ZKP. Essentially, for Alice to prove to Bob that $\log_a(e_1) = \log_b(e_2)$ is some common value $x \in \mathbb{Z}_q$ -- when Bob knows $a,b,e_1,e_2$ -- Alice picks some random $s \in_R \mathbb{Z}_q$ and sends Bob $a^s$ and $b^s$.  Bob then sends Alice a challenge $c \in \mathbb{Z}_q^*$, to which Alice must respond with $t = s-cx$ mod $q$.  Bob will accept if $a^s = a^t e_1^{c}$ and $b^s = b^t e_2^{c}$.  See the paper of Chaum and Pedersen~\cite{ChPe92} for details and information about the scheme's security.
\item Each member $P_i$ computes, for each $j \neq i$,
\[ \kappa_{ij}^{MAC} = H(K_{ij} || \text{`MAC'}) \qquad \kappa_{ij}^{KC} = H(K_{ij} || \text{`KC'}) \] 
where $H$ is a suitable hash function, and broadcasts
\begin{align*}
t_{ij}^{MAC} &= HMAC(\kappa_{ij}^{MAC},  g^{y_i} || \text{ZKP}\{y_i\} || (g^{z_i})^{y_i} || \text{ZKP}\{\tilde{y_i}\})\\
        t_{ij}^{KC} &= HMAC(\kappa_{ij}^{KC}, ``KC''|| i || j || A_{ij}),
\end{align*}
where HMAC is a suitable keyed-hash message authentication code -- that is, a MAC which is based on a hash function -- and $A_{ij}$ is a concatentation of all information required to compute the shared key for the pairwise PAKE between $P_i$ and $P_j$ (this is elaborated on in the four examples below).
\item If agent $P_i$ is able to verify all Zero Knowledge Proofs sent by all other group members, and can verify the message authentication codes $t_{ji}^{MAC}$ and $t_{ji}^{KC}$ for all $j \neq i$, then $P_i$ accepts and calculates the shared group key
\begin{equation} K = (g^{y_{i-1}})^{n \cdot y_i} (g^{z_iy_i})^{n-1}(g^{z_{i+1}y_{i+1}})^{n-2} \cdots (g^{z_{i-2}y_{i-1}})^{n-1} =  g^{y_1 \cdot y_2 + y_2 \cdot y_3 + \cdots + y_n \cdot y_1}, \label{eq:key} \end{equation}
where again the indices in the above equation are taken modulo $n$. The steps used to compute the key (namely, the construction of the group key using the elements $g^{y_i}$ and $g^{z_i}$) are based on the Burmester-Desmedt cyclic key computation technique, which was used by Burmester and Desmedt~\cite{BuDe95} to construct a shared secure key amongst a group of agents using Public Key Infrastructure.  In their article, Burmester and Desmedt show the security of the scheme under a realistic attack model assuming the intractability of the DDH.
\item[]
\end{itemize}

In their paper, Hao et. al.~\cite{HaYiChSh15} give arguments showing the security of the resulting GPAKE, in an informal attack model where $\alpha$ of the $n$ group participants are legitimate group members and $n-\alpha$ members are active attackers which can send/receive/modify messages as usual (there may also be passive attackers watching the exchange take place).  Their  explanation shows that -- under assumptions such as the hardness of the DDH, the security of the Schnorr and Chaum-Pedersen ZKPs, and the security of the Burmester-Desmedt group key agreement protocol -- when the underlying PAKE has each of the four security properties discussed in Section \ref{sec:PAKE} (offline dictionary attack resistance, forward secrecy for established keys, known session security, and online dictionary attack resistance) then so will the resulting GPAKE, where online dictionary attack resistance now means that at most $\alpha \cdot (n - \alpha)$ passwords may be guessed in one run of the protocol (each active attacker can try one guess of the password with each authentic password holders).  Their argument for security roughly takes the following form: the shared key is constructed from the Burmester-Desmedt group key agreement protocol, which is secure when Public Key Architecture is available.  In order to verify participants as authentic password holders without PKI -- in order to prevent man in the middle attacks, for instance -- a pairwise PAKE is established between each pair of members.  Assuming the underlying PAKE is secure, this will correctly identify attackers. For the full argument, we refer the reader to Hao et. al.~\cite{HaYiChSh15}.
\\

We note also that the verification of $t_{ij}^{MAC}$ by each group member results in key confirmation for the GPAKE scheme, in the sense that any group member will know that all other group members have all information needed to calculate the shared key (verification of $t_{ij}^{KC}$ results in key confirmation in each pairwise scheme).  We now give four explicit schemes derived by this method, beginning with the two GPAKES of Hao et. al.



